From e980527ecaefb7ff0acb75de56fa68be54a20c22 Mon Sep 17 00:00:00 2001
From: Einhornhool <26007369+Einhornhool@users.noreply.github.com>
Date: Sat, 3 Oct 2020 13:54:10 +0300
Subject: [PATCH] Use RIOT SHA256 PRNG instead of HWRNG

---
 platform-specific.inc |  6 +++---
 uECC.c                | 24 ++++++++++++++++++------
 uECC.h                | 12 ++++++------
 3 files changed, 27 insertions(+), 15 deletions(-)

diff --git a/platform-specific.inc b/platform-specific.inc
index cb0ac42..4fdb284 100644
--- a/platform-specific.inc
+++ b/platform-specific.inc
@@ -5,7 +5,7 @@
 
 #include "types.h"
 
-#ifdef MODULE_PERIPH_HWRNG
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 
 #if (defined(_WIN32) || defined(_WIN64))
 /* Windows */
@@ -46,7 +46,7 @@ static int default_RNG(uint8_t *dest, unsigned size) {
             return 0;
         }
     }
-    
+
     char *ptr = (char *)dest;
     size_t left = size;
     while (left > 0) {
@@ -58,7 +58,7 @@ static int default_RNG(uint8_t *dest, unsigned size) {
         left -= bytes_read;
         ptr += bytes_read;
     }
-    
+
     close(fd);
     return 1;
 }
diff --git a/uECC.c b/uECC.c
index ca331a9..e066f10 100644
--- a/uECC.c
+++ b/uECC.c
@@ -1,11 +1,16 @@
 /* Copyright 2014, Kenneth MacKay. Licensed under the BSD 2-clause license. */
 
+#include <stdlib.h>
 #include "uECC.h"
 #include "uECC_vli.h"
 #ifdef MODULE_PERIPH_HWRNG
 #include "periph/hwrng.h"
 #endif
 
+#ifdef MODULE_PRNG_SHA256PRNG
+void _random_bytes(uint8_t *bytes, size_t size);
+#endif
+
 #ifndef uECC_RNG_MAX_TRIES
     #define uECC_RNG_MAX_TRIES 64
 #endif
@@ -191,7 +196,14 @@ int riot_hwrng(uint8_t *dest, unsigned size) {
 }
 #endif
 
-#ifdef MODULE_PERIPH_HWRNG
+#ifdef MODULE_PRNG_SHA256PRNG
+int riot_hwrng(uint8_t *dest, unsigned size) {
+    _random_bytes(dest, size);
+    return 1;
+}
+#endif
+
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 #if default_RNG_defined
 static uECC_RNG_Function g_rng_function = &default_RNG;
 #else
@@ -1015,7 +1027,7 @@ uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
     return 0;
 }
 
-#ifdef MODULE_PERIPH_HWRNG
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 
 int uECC_make_key(uint8_t *public_key,
                   uint8_t *private_key,
@@ -1228,7 +1240,7 @@ static void bits2int(uECC_word_t *native,
     bcopy((uint8_t *) native, bits, bits_size);
 #else
     uECC_vli_bytesToNative(native, bits, bits_size);
-#endif    
+#endif
     if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
         return;
     }
@@ -1317,11 +1329,11 @@ static int uECC_sign_with_k(const uint8_t *private_key,
     bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);
 #else
     uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);
-#endif    
+#endif
     return 1;
 }
 
-#ifdef MODULE_PERIPH_HWRNG
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 
 int uECC_sign(const uint8_t *private_key,
               const uint8_t *message_hash,
@@ -1494,7 +1506,7 @@ int uECC_verify(const uint8_t *public_key,
     uECC_word_t *public = (uECC_word_t *)public_key;
 #else
     uECC_word_t public[uECC_MAX_WORDS * 2];
-#endif    
+#endif
     uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
     wordcount_t num_words = curve->num_words;
     wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
diff --git a/uECC.h b/uECC.h
index dc40721..7b5f39d 100644
--- a/uECC.h
+++ b/uECC.h
@@ -36,12 +36,12 @@ faster somewhat faster, but increases the code size. */
 #endif
 
 /* uECC_VLI_NATIVE_LITTLE_ENDIAN - If enabled (defined as nonzero), this will switch to native
-little-endian format for *all* arrays passed in and out of the public API. This includes public 
-and private keys, shared secrets, signatures and message hashes. 
+little-endian format for *all* arrays passed in and out of the public API. This includes public
+and private keys, shared secrets, signatures and message hashes.
 Using this switch reduces the amount of call stack memory used by uECC, since less intermediate
-translations are required. 
+translations are required.
 Note that this will *only* work on native little-endian processors and it will treat the uint8_t
-arrays passed into the public API as word arrays, therefore requiring the provided byte arrays 
+arrays passed into the public API as word arrays, therefore requiring the provided byte arrays
 to be word aligned on architectures that do not support unaligned accesses. */
 #ifndef uECC_VLI_NATIVE_LITTLE_ENDIAN
     #define uECC_VLI_NATIVE_LITTLE_ENDIAN 0
@@ -142,7 +142,7 @@ Returns the size of a public key for the curve in bytes.
 */
 int uECC_curve_public_key_size(uECC_Curve curve);
 
-#ifdef MODULE_PERIPH_HWRNG
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 
 /* uECC_make_key() function.
 Create a public/private key pair.
@@ -237,7 +237,7 @@ Returns 1 if the key was computed successfully, 0 if an error occurred.
 */
 int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve);
 
-#ifdef MODULE_PERIPH_HWRNG
+#if (MODULE_PERIPH_HWRNG || MODULE_PRNG_SHA256PRNG)
 
 /* uECC_sign() function.
 Generate an ECDSA signature for a given hash value.
-- 
2.17.1

